/**
 * EpicWeatherBox Firmware - Display Driver Implementation
 *
 * Pixel art weather display with 10-second cycling between locations.
 * Each location shows 3 screens: Current, Days 1-3 forecast, Days 4-6 forecast.
 */

#include "display.h"
#include "config.h"
#include <NTPClient.h>

// External NTP client (from main.cpp)
extern NTPClient timeClient;

// =============================================================================
// TFT DISPLAY INSTANCE
// =============================================================================

static TFT_eSPI tft = TFT_eSPI();
static TFT_eSprite sprite = TFT_eSprite(&tft);  // Double buffering sprite

// =============================================================================
// STATE VARIABLES
// =============================================================================

static int currentLocationIndex = 0;
static ScreenType currentScreen = SCREEN_CURRENT_WEATHER;
static unsigned long lastScreenChange = 0;
static unsigned long lastFrameTime = 0;
static int displayBrightness = BRIGHTNESS_DEFAULT;
static bool displayOn = true;
static bool needsRedraw = true;

// =============================================================================
// 32x32 PIXEL ART WEATHER ICONS (XBM Format)
// Hand-drawn pixel art, inspired by weather-pixel-icons project
// =============================================================================

// Sun icon (32x32)
static const unsigned char PROGMEM icon_sun[] = {
    0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
    0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x08, 0x30, 0x00, 0x00, 0x0C,
    0x60, 0xE0, 0x07, 0x06, 0x00, 0xF8, 0x1F, 0x00, 0x00, 0x1C, 0x38, 0x00,
    0x00, 0x0E, 0x70, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x80, 0x03, 0xC0, 0x01,
    0x80, 0x03, 0xC0, 0x01, 0xFC, 0x01, 0x80, 0x3F, 0xFC, 0x01, 0x80, 0x3F,
    0x80, 0x03, 0xC0, 0x01, 0x80, 0x03, 0xC0, 0x01, 0x00, 0x07, 0xE0, 0x00,
    0x00, 0x0E, 0x70, 0x00, 0x00, 0x1C, 0x38, 0x00, 0x00, 0xF8, 0x1F, 0x00,
    0x60, 0xE0, 0x07, 0x06, 0x30, 0x00, 0x00, 0x0C, 0x10, 0x00, 0x00, 0x08,
    0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x80, 0x01, 0x00,
    0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Moon icon (32x32)
static const unsigned char PROGMEM icon_moon[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0xF0, 0x3F, 0x00,
    0x00, 0xF8, 0x7F, 0x00, 0x00, 0xFC, 0x7F, 0x00, 0x00, 0xFE, 0x3F, 0x00,
    0x00, 0xFE, 0x1F, 0x00, 0x00, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0x07, 0x00,
    0x80, 0xFF, 0x07, 0x00, 0x80, 0xFF, 0x03, 0x00, 0x80, 0xFF, 0x03, 0x00,
    0xC0, 0xFF, 0x03, 0x00, 0xC0, 0xFF, 0x03, 0x00, 0xC0, 0xFF, 0x03, 0x00,
    0xC0, 0xFF, 0x03, 0x00, 0xC0, 0xFF, 0x03, 0x00, 0xC0, 0xFF, 0x03, 0x00,
    0x80, 0xFF, 0x07, 0x00, 0x80, 0xFF, 0x07, 0x00, 0x00, 0xFF, 0x0F, 0x00,
    0x00, 0xFE, 0x1F, 0x00, 0x00, 0xFC, 0x3F, 0x00, 0x00, 0xF8, 0x7F, 0x00,
    0x00, 0xF0, 0xFF, 0x00, 0x00, 0xC0, 0xFF, 0x01, 0x00, 0x00, 0xFF, 0x03,
    0x00, 0x00, 0xFC, 0x03, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Cloud icon (32x32)
static const unsigned char PROGMEM icon_cloud[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00,
    0x00, 0xF8, 0x0F, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x06, 0x38, 0x00,
    0x00, 0x07, 0x70, 0x00, 0x80, 0x03, 0x60, 0x00, 0xC0, 0x01, 0xE0, 0x00,
    0xE0, 0x00, 0xC0, 0x01, 0x70, 0x00, 0xC0, 0x03, 0x38, 0x00, 0x80, 0x07,
    0x1C, 0x00, 0x00, 0x07, 0x0E, 0x00, 0x00, 0x0E, 0x06, 0x00, 0x00, 0x0C,
    0x06, 0x00, 0x00, 0x0C, 0x06, 0x00, 0x00, 0x0C, 0x0E, 0x00, 0x00, 0x0E,
    0xFC, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Partly cloudy (sun + cloud) icon (32x32)
static const unsigned char PROGMEM icon_partly_cloudy[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x01, 0x0C, 0x00, 0x80, 0x01, 0x00, 0xE0, 0x01, 0x00,
    0x00, 0xF0, 0x03, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x0C, 0x0C, 0x00,
    0x00, 0x06, 0x18, 0x00, 0xF0, 0x07, 0x18, 0x00, 0xF0, 0x03, 0x18, 0x00,
    0x00, 0x06, 0x0C, 0x00, 0x00, 0x1C, 0xC6, 0x03, 0x00, 0xF0, 0xF9, 0x07,
    0x00, 0x00, 0x1C, 0x0E, 0x00, 0x00, 0x06, 0x1C, 0x00, 0x00, 0x07, 0x38,
    0x80, 0x81, 0x03, 0x30, 0xC0, 0xC0, 0x01, 0x70, 0xE0, 0xE0, 0x00, 0xE0,
    0x70, 0x60, 0x00, 0xC0, 0x18, 0x00, 0x00, 0xC0, 0x0C, 0x00, 0x00, 0xC0,
    0x0E, 0x00, 0x00, 0xE0, 0xFE, 0xFF, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0x3F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Rain icon (32x32)
static const unsigned char PROGMEM icon_rain[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0xF8, 0x0F, 0x00,
    0x00, 0x1C, 0x1C, 0x00, 0x00, 0x06, 0x38, 0x00, 0x00, 0x07, 0x70, 0x00,
    0x80, 0x03, 0x60, 0x00, 0xC0, 0x01, 0xE0, 0x00, 0xE0, 0x00, 0xC0, 0x01,
    0x70, 0x00, 0xC0, 0x03, 0x38, 0x00, 0x80, 0x07, 0x1C, 0x00, 0x00, 0x07,
    0x0E, 0x00, 0x00, 0x0E, 0x06, 0x00, 0x00, 0x0C, 0x0E, 0x00, 0x00, 0x0E,
    0xFC, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x84, 0x10, 0x00, 0x00, 0x42, 0x08, 0x00, 0x00, 0x21, 0x04, 0x00,
    0x80, 0x10, 0x82, 0x00, 0x40, 0x08, 0x41, 0x00, 0x00, 0x84, 0x20, 0x00,
    0x00, 0x42, 0x10, 0x00, 0x00, 0x21, 0x08, 0x00, 0x80, 0x10, 0x04, 0x00,
    0x40, 0x08, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Snow icon (32x32)
static const unsigned char PROGMEM icon_snow[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0xF8, 0x0F, 0x00,
    0x00, 0x1C, 0x1C, 0x00, 0x00, 0x06, 0x38, 0x00, 0x00, 0x07, 0x70, 0x00,
    0x80, 0x03, 0x60, 0x00, 0xC0, 0x01, 0xE0, 0x00, 0xE0, 0x00, 0xC0, 0x01,
    0x70, 0x00, 0xC0, 0x03, 0x38, 0x00, 0x80, 0x07, 0x1C, 0x00, 0x00, 0x07,
    0x0E, 0x00, 0x00, 0x0E, 0x06, 0x00, 0x00, 0x0C, 0x0E, 0x00, 0x00, 0x0E,
    0xFC, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x42, 0x08, 0x00, 0x00, 0xE7, 0x1C, 0x00, 0x00, 0x42, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x08, 0x21, 0x00, 0xE0, 0x1C, 0x73, 0x00,
    0x40, 0x08, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x08, 0x00,
    0x00, 0xE7, 0x1C, 0x00, 0x00, 0x42, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Thunderstorm icon (32x32)
static const unsigned char PROGMEM icon_thunder[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0xF8, 0x0F, 0x00,
    0x00, 0x1C, 0x1C, 0x00, 0x00, 0x06, 0x38, 0x00, 0x00, 0x07, 0x70, 0x00,
    0x80, 0x03, 0x60, 0x00, 0xC0, 0x01, 0xE0, 0x00, 0xE0, 0x00, 0xC0, 0x01,
    0x70, 0x00, 0xC0, 0x03, 0x38, 0x00, 0x80, 0x07, 0x1C, 0x00, 0x00, 0x07,
    0x0E, 0x00, 0x00, 0x0E, 0x06, 0x00, 0x00, 0x0C, 0x0E, 0x00, 0x00, 0x0E,
    0xFC, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0xF0, 0x00, 0x00,
    0x00, 0x78, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00,
    0x00, 0xFF, 0x01, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00,
    0x00, 0x3C, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00,
    0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Fog icon (32x32)
static const unsigned char PROGMEM icon_fog[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0xFF, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0xFF, 0xFF, 0x0F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F,
    0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0xFF, 0xFF, 0x0F, 0xF0, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0xFC, 0xFF, 0xFF, 0x3F,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Drizzle icon (32x32)
static const unsigned char PROGMEM icon_drizzle[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0xF8, 0x0F, 0x00,
    0x00, 0x1C, 0x1C, 0x00, 0x00, 0x06, 0x38, 0x00, 0x00, 0x07, 0x70, 0x00,
    0x80, 0x03, 0x60, 0x00, 0xC0, 0x01, 0xE0, 0x00, 0xE0, 0x00, 0xC0, 0x01,
    0x70, 0x00, 0xC0, 0x03, 0x38, 0x00, 0x80, 0x07, 0x1C, 0x00, 0x00, 0x07,
    0x0E, 0x00, 0x00, 0x0E, 0x06, 0x00, 0x00, 0x0C, 0x0E, 0x00, 0x00, 0x0E,
    0xFC, 0xFF, 0xFF, 0x07, 0xF8, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x88, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Unknown/question mark icon (32x32)
static const unsigned char PROGMEM icon_unknown[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x1F, 0x00, 0x00, 0xFE, 0x7F, 0x00,
    0x00, 0x0F, 0xF0, 0x00, 0x80, 0x03, 0xC0, 0x01, 0xC0, 0x01, 0x80, 0x03,
    0xC0, 0x00, 0x00, 0x03, 0xE0, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 0x07,
    0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x80, 0x03, 0x00, 0x00, 0xC0, 0x01,
    0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x38, 0x00,
    0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// =============================================================================
// ICON LOOKUP
// =============================================================================

static const unsigned char* getIconForCondition(WeatherCondition condition, bool isDay) {
    switch (condition) {
        case WEATHER_CLEAR:
            return isDay ? icon_sun : icon_moon;
        case WEATHER_PARTLY_CLOUDY:
            return icon_partly_cloudy;
        case WEATHER_CLOUDY:
            return icon_cloud;
        case WEATHER_FOG:
            return icon_fog;
        case WEATHER_DRIZZLE:
            return icon_drizzle;
        case WEATHER_RAIN:
        case WEATHER_FREEZING_RAIN:
            return icon_rain;
        case WEATHER_SNOW:
            return icon_snow;
        case WEATHER_THUNDERSTORM:
            return icon_thunder;
        default:
            return icon_unknown;
    }
}

static uint16_t getIconColor(WeatherCondition condition, bool isDay) {
    switch (condition) {
        case WEATHER_CLEAR:
            return isDay ? COLOR_SUN : COLOR_MOON;
        case WEATHER_PARTLY_CLOUDY:
        case WEATHER_CLOUDY:
        case WEATHER_FOG:
            return COLOR_CLOUD;
        case WEATHER_DRIZZLE:
        case WEATHER_RAIN:
        case WEATHER_FREEZING_RAIN:
            return COLOR_RAIN;
        case WEATHER_SNOW:
            return COLOR_SNOW;
        case WEATHER_THUNDERSTORM:
            return COLOR_THUNDER;
        default:
            return COLOR_TEXT_WHITE;
    }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

void initDisplay() {
    Serial.println(F("[DISPLAY] Initializing TFT..."));

    // Initialize TFT
    tft.init();
    tft.setRotation(0);  // Portrait mode
    tft.fillScreen(TFT_BLACK);

    // Setup backlight PWM
    pinMode(TFT_BL_PIN, OUTPUT);
    analogWriteRange(100);
    analogWriteFreq(1000);
    setDisplayBrightness(displayBrightness);

    // Create sprite for double buffering (full screen)
    sprite.createSprite(SCREEN_WIDTH, SCREEN_HEIGHT);
    sprite.setSwapBytes(true);

    Serial.println(F("[DISPLAY] TFT initialized"));
    Serial.printf("[DISPLAY] Resolution: %dx%d\n", SCREEN_WIDTH, SCREEN_HEIGHT);

    // Draw initial screen
    needsRedraw = true;
    lastScreenChange = millis();
}

// =============================================================================
// MAIN UPDATE LOOP
// =============================================================================

void updateDisplay() {
    if (!displayOn) return;

    unsigned long now = millis();

    // Check if it's time to change screen
    if (now - lastScreenChange >= SCREEN_DISPLAY_TIME_MS) {
        lastScreenChange = now;
        needsRedraw = true;

        // Advance to next screen
        currentScreen = (ScreenType)((currentScreen + 1) % SCREEN_TYPE_COUNT);

        // If we completed all screens for this location, move to next location
        if (currentScreen == SCREEN_CURRENT_WEATHER) {
            int locationCount = getLocationCount();
            if (locationCount > 0) {
                currentLocationIndex = (currentLocationIndex + 1) % locationCount;
            }
        }

        Serial.printf("[DISPLAY] Screen: %d, Location: %d\n", currentScreen, currentLocationIndex);
    }

    // Redraw if needed
    if (needsRedraw) {
        needsRedraw = false;

        // Get background color based on day/night
        const WeatherData& weather = getWeather(currentLocationIndex);
        uint16_t bgColor = weather.current.isDay ? COLOR_BG_DAY : COLOR_BG_NIGHT;

        sprite.fillSprite(bgColor);

        switch (currentScreen) {
            case SCREEN_CURRENT_WEATHER:
                drawCurrentWeatherScreen(currentLocationIndex);
                break;
            case SCREEN_FORECAST_1_3:
                drawForecastScreen(currentLocationIndex, 0);
                break;
            case SCREEN_FORECAST_4_6:
                drawForecastScreen(currentLocationIndex, 3);
                break;
        }

        // Push sprite to display
        sprite.pushSprite(0, 0);
    }
}

void refreshDisplay() {
    needsRedraw = true;
}

// =============================================================================
// BRIGHTNESS CONTROL
// =============================================================================

void setDisplayBrightness(int brightness) {
    displayBrightness = constrain(brightness, BRIGHTNESS_MIN, BRIGHTNESS_MAX);
    analogWrite(TFT_BL_PIN, displayBrightness);
}

int getDisplayBrightness() {
    return displayBrightness;
}

void setDisplayOn(bool on) {
    displayOn = on;
    if (on) {
        setDisplayBrightness(displayBrightness);
        needsRedraw = true;
    } else {
        analogWrite(TFT_BL_PIN, 0);
    }
}

bool isDisplayOn() {
    return displayOn;
}

// =============================================================================
// CURRENT WEATHER SCREEN
// =============================================================================

void drawCurrentWeatherScreen(int locationIndex) {
    const WeatherData& weather = getWeather(locationIndex);
    const WeatherLocation& location = getLocation(locationIndex);

    // Get current time
    unsigned long epochTime = timeClient.getEpochTime();
    int hours = (epochTime % 86400L) / 3600;
    int minutes = (epochTime % 3600) / 60;

    // Draw time at top (large pixel font)
    sprite.setTextColor(COLOR_TEXT_WHITE);
    sprite.setTextDatum(TC_DATUM);

    // Time in big font
    char timeStr[6];
    snprintf(timeStr, sizeof(timeStr), "%02d:%02d", hours, minutes);
    sprite.setTextSize(1);
    sprite.setFreeFont(&FreeSansBold24pt7b);
    sprite.drawString(timeStr, SCREEN_WIDTH / 2, 15);

    // Location name below time
    sprite.setFreeFont(&FreeSans12pt7b);
    sprite.setTextColor(COLOR_TEXT_LIGHT);
    sprite.drawString(location.name, SCREEN_WIDTH / 2, 65);

    // Draw weather icon (centered, large)
    int iconX = (SCREEN_WIDTH - 64) / 2;
    int iconY = 95;
    drawWeatherIcon(weather.current.condition, iconX, iconY, 64, weather.current.isDay);

    // Current temperature (big)
    sprite.setTextDatum(TC_DATUM);
    drawTemperature(weather.current.temperature, SCREEN_WIDTH / 2, 170, 3);

    // Condition text
    sprite.setFreeFont(&FreeSans9pt7b);
    sprite.setTextColor(COLOR_TEXT_LIGHT);
    sprite.drawString(conditionToString(weather.current.condition), SCREEN_WIDTH / 2, 210);

    // Location indicator dots at bottom
    int numLocations = getLocationCount();
    if (numLocations > 1) {
        int dotSpacing = 12;
        int startX = (SCREEN_WIDTH - (numLocations - 1) * dotSpacing) / 2;
        for (int i = 0; i < numLocations; i++) {
            uint16_t dotColor = (i == locationIndex) ? COLOR_TEXT_WHITE : COLOR_TEXT_LIGHT;
            sprite.fillCircle(startX + i * dotSpacing, 232, 3, dotColor);
        }
    }
}

// =============================================================================
// FORECAST SCREEN
// =============================================================================

void drawForecastScreen(int locationIndex, int startDay) {
    const WeatherData& weather = getWeather(locationIndex);
    const WeatherLocation& location = getLocation(locationIndex);

    // Title
    sprite.setTextColor(COLOR_TEXT_WHITE);
    sprite.setTextDatum(TC_DATUM);
    sprite.setFreeFont(&FreeSans12pt7b);

    char title[32];
    if (startDay == 0) {
        snprintf(title, sizeof(title), "%s - Days 1-3", location.name);
    } else {
        snprintf(title, sizeof(title), "%s - Days 4-6", location.name);
    }
    sprite.drawString(title, SCREEN_WIDTH / 2, 10);

    // Draw 3 forecast cards
    int cardWidth = 70;
    int cardHeight = 160;
    int cardSpacing = 8;
    int startX = (SCREEN_WIDTH - 3 * cardWidth - 2 * cardSpacing) / 2;
    int cardY = 45;

    for (int i = 0; i < 3; i++) {
        int dayIndex = startDay + i;
        if (dayIndex >= weather.forecastDays) continue;

        const ForecastDay& day = weather.forecast[dayIndex];
        int cardX = startX + i * (cardWidth + cardSpacing);

        // Draw card background
        drawCard(cardX, cardY, cardWidth, cardHeight, COLOR_CARD_BG);

        // Day name
        sprite.setTextDatum(TC_DATUM);
        sprite.setTextColor(COLOR_TEXT_WHITE);
        sprite.setFreeFont(&FreeSans9pt7b);
        sprite.drawString(day.dayName, cardX + cardWidth / 2, cardY + 8);

        // Weather icon
        int iconX = cardX + (cardWidth - 32) / 2;
        int iconY = cardY + 35;
        drawWeatherIcon(day.condition, iconX, iconY, 32, true);

        // High temp
        sprite.setTextDatum(TC_DATUM);
        sprite.setTextColor(getTempColor(day.tempMax));
        sprite.setFreeFont(&FreeSans9pt7b);
        String highTemp = formatTemp(day.tempMax);
        sprite.drawString(highTemp, cardX + cardWidth / 2, cardY + 80);

        // Low temp
        sprite.setTextColor(getTempColor(day.tempMin));
        String lowTemp = formatTemp(day.tempMin);
        sprite.drawString(lowTemp, cardX + cardWidth / 2, cardY + 105);

        // Precipitation probability
        if (day.precipitationProb > 0) {
            sprite.setTextColor(COLOR_RAIN);
            sprite.setFreeFont(&FreeMono9pt7b);
            char precip[8];
            snprintf(precip, sizeof(precip), "%d%%", (int)day.precipitationProb);
            sprite.drawString(precip, cardX + cardWidth / 2, cardY + 135);
        }
    }

    // Location indicator dots at bottom
    int numLocations = getLocationCount();
    if (numLocations > 1) {
        int dotSpacing = 12;
        int startXDots = (SCREEN_WIDTH - (numLocations - 1) * dotSpacing) / 2;
        for (int i = 0; i < numLocations; i++) {
            uint16_t dotColor = (i == locationIndex) ? COLOR_TEXT_WHITE : COLOR_TEXT_LIGHT;
            sprite.fillCircle(startXDots + i * dotSpacing, 232, 3, dotColor);
        }
    }
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

void drawWeatherIcon(WeatherCondition condition, int x, int y, int size, bool isDay) {
    const unsigned char* icon = getIconForCondition(condition, isDay);
    uint16_t color = getIconColor(condition, isDay);

    if (size == 32) {
        sprite.drawXBitmap(x, y, icon, 32, 32, color);
    } else if (size == 64) {
        // Scale up 32x32 to 64x64 (2x)
        // TFT_eSPI doesn't have built-in scaling, so we'll do pixel doubling
        for (int py = 0; py < 32; py++) {
            for (int px = 0; px < 32; px++) {
                int byteIndex = py * 4 + px / 8;
                int bitIndex = px % 8;
                uint8_t b = pgm_read_byte(&icon[byteIndex]);
                if (b & (1 << bitIndex)) {
                    // Draw 2x2 block
                    sprite.fillRect(x + px * 2, y + py * 2, 2, 2, color);
                }
            }
        }
    }
}

void drawTemperature(float temp, int x, int y, int size) {
    sprite.setTextColor(getTempColor(temp));
    sprite.setTextDatum(TC_DATUM);

    if (size == 3) {
        sprite.setFreeFont(&FreeSansBold18pt7b);
    } else if (size == 2) {
        sprite.setFreeFont(&FreeSans12pt7b);
    } else {
        sprite.setFreeFont(&FreeSans9pt7b);
    }

    String tempStr = formatTemp(temp);
    sprite.drawString(tempStr, x, y);
}

uint16_t getTempColor(float temp) {
    // Color based on temperature (assuming Celsius or converted)
    if (temp < 0) return COLOR_TEXT_BLUE;
    if (temp < 10) return COLOR_TEXT_CYAN;
    if (temp < 20) return COLOR_TEXT_WHITE;
    if (temp < 30) return COLOR_TEXT_ORANGE;
    return COLOR_TEXT_ORANGE;  // Hot
}

String formatTemp(float temp) {
    bool useCelsius = getUseCelsius();
    if (!useCelsius) {
        temp = temp * 9.0 / 5.0 + 32.0;
    }
    char buf[12];
    snprintf(buf, sizeof(buf), "%.0f%s", temp, useCelsius ? "C" : "F");
    return String(buf);
}

void drawCard(int x, int y, int w, int h, uint16_t color) {
    // Draw rounded rectangle (pixel art style - just use regular rect)
    sprite.fillRoundRect(x, y, w, h, 4, color);
}
